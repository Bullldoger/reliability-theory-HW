%% Подсчет определителя матрицы 3 на 3(в тупую)
det([[A11, A12, A13], [A21, A22, A23], [A31, A32, A33]], D) :-	D is A11 * A22 * A33 
																	- A11 * A32 * A23
																	- A12 * A21 * A33
																	+ A12 * A23 * A31
																	+ A13 * A21 * A32
																	- A13 * A22 * A31.

%% Как на сайте http://www.academiaxxi.ru/WWW_Books/HM/Ag/01/09/e.htm - из 4-х точек формируется 3 вектора и считается определитель полученной матрицы, если 0 - то лежат
diff([[A11, A12, A13], [A21, A22, A23], [A31, A32, A33]], [X1, X2, X3], D) :-	det([[A11 - X1, A12 - X2, A13 - X3], [A21 - X1, A22 - X2, A23 - X3], [A31 - X1, A32 - X2, A33 - X3]], D).

%% Создается список точек лежащих в одной плоскости на основе произвольных 3-х и поочередно добавляются те точки, которые не учавствуют в построении точки
%% 
createList(_, [], []) :-	!.
%% 
createList(BASEPOINT, [H|T], OUTLIST) :-	
											%% рекурсивно вниз
											createList(BASEPOINT, T, OUTLIST1),
											%% вычисление определителя, для выяснения лежат ли точки в одном плоскости
											diff(BASEPOINT, H, D),
											%% если определитель равен 0, то точки лежат в одной плоскости, иначе нет
											(D = 0
											->
											append(OUTLIST1, [H], OUTLIST);
											append([], OUTLIST1, OUTLIST)
											).

%% Из списка точек удаляются те, по которым строится плоскость и остаются только те, которые проверяются на принадлежность плоскости
%% Остановка, если список "позиций" точек подлежащих удалению, пуст
deleteElementsAtPositions(L, _, [], L).
%% Если список точек пуст, то остановка
deleteElementsAtPositions([], CURRENTPOS, _, []).
%% если позиция точки входит в список позиций для удаления, то данная точка не входит в список
deleteElementsAtPositions([H|T], CURRENTPOS, [POS|POSITIONS], NEWLIST) :-	
																			%% вычисляется следующий индекс
																			NEXTPOSITION is CURRENTPOS + 1,
																			%% проверка, входит ли данная позиция в список заданных для удаления
																			(CURRENTPOS = POS
																			->
																			deleteElementsAtPositions(T, NEXTPOSITION, POSITIONS, NEWLIST1),
																			append(NEWLIST1, [], NEWLIST)
																			;
																			deleteElementsAtPositions(T, NEXTPOSITION, [POS|POSITIONS], NEWLIST1),
																			append(NEWLIST1, [H], NEWLIST)
																			),
																			!.

%% Вывод списка
%% Критерий остановки вывод - пустой список
printList([]).
printList([H|T]) :-	
					%% вывод элемента списка
					print(H),
					%% перенос строки
					nl,
					%% далее рекурсивно вниз
					printList(T).

%% Генерация всех сочетаний из 3-х точек и построение плоскостей
%% Остановка, если список точек пуст и список базисных точек также пуст
gen([], [], _, _, _, _, _) :-	!.
%% Список точек пуст и в списке базисных точек только одна
gen([], [P1], [], _, _, _, _) :-	!.
%%  Список точек пуст и в списке базисных точек 2
gen([], [P1, P2], [], _, _, _, _) :-	!.
%% Если базисных точек 3, строится плоскость и по точкам, не входящим в список базисных начинается обход для проверки какие из них лежат плоскости, образованной базисными точками
gen(_, [P1, P2, P3], O, POINTS, OUT, POS, POSITIONS) :-	
														%% Добавление 3-ки базисных точек в список О
														append([], [[P1, P2, P3]], O),	
														%% Из списка всех точек удаляются те, по которым строится плоскость
														deleteElementsAtPositions(POINTS, 1, POSITIONS, CLEANELEMS),
														%% формируется список точек лежащих в плоскости построенной по базисным точкам
														createList([P1, P2, P3], CLEANELEMS, POINTS_LIST),
														%% добавление базисных точек в список тех, которые лежат в одной плоскости с ними
														append(POINTS_LIST, [P1, P2, P3], RESPOINTS),
														%% вычисление количества точек лежащих в заданной плоскости и если их 4 и более, то этот список нам подходит
														length(RESPOINTS, N),
														(N > 3
														->
														append([], [RESPOINTS], OUT);
														append([], [], OUT)
														).

gen([H|T], L, O, POINTS, OUT, POS, POSITIONS) :-	
													%% добавление H в список базисных точек
													append(L, [H], L1),
													%% добавление позиции точки H в список индексов точек, вошедших в базис
													append(POSITIONS, [POS], NEWPOSITIONS),
													%% вычисляется следующий индекс(позиция)
													POSNEXT is POS + 1,
													%% рекурсивно вниз с пустым список базисных точек и оставшейся части списка точек
													gen(T, L, O1, POINTS, LP1, POSNEXT, POSITIONS),
													%% рекурсивно вниз с частичным базисом точек и оставшейся части списка точек
													gen(T, L1, O2, POINTS, LP2, POSNEXT, NEWPOSITIONS),
													%% соединение списков точек лежащих в одной плоскости
													append(LP1, LP2, OUT),
													%% 
													append(O1, O2, O).
%% Стартовый предикат, который получает список точек(POINTS) и LIST - результат - все множества точек из одной плоскости
start(POINTS, LIST) :-	gen(POINTS, [], O, POINTS, LIST, 1, []), !.
